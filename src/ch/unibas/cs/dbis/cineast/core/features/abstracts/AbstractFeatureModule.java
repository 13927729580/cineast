package ch.unibas.cs.dbis.cineast.core.features.abstracts;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ch.unibas.cs.dbis.cineast.core.config.Config;
import ch.unibas.cs.dbis.cineast.core.config.QueryConfig;
import ch.unibas.cs.dbis.cineast.core.data.ReadableFloatVector;
import ch.unibas.cs.dbis.cineast.core.data.StringDoublePair;
import ch.unibas.cs.dbis.cineast.core.db.DBSelector;
import ch.unibas.cs.dbis.cineast.core.db.PersistencyWriter;
import ch.unibas.cs.dbis.cineast.core.db.PersistentTuple;
import ch.unibas.cs.dbis.cineast.core.features.extractor.Extractor;
import ch.unibas.cs.dbis.cineast.core.features.retriever.Retriever;
import ch.unibas.cs.dbis.cineast.core.util.MathHelper;
import gnu.trove.map.TObjectDoubleMap;
import gnu.trove.map.hash.TObjectDoubleHashMap;

public abstract class AbstractFeatureModule implements Extractor, Retriever {

//	private static Logger LOGGER = LogManager.getLogger();
	
	protected PersistencyWriter<?> phandler;
	protected DBSelector selector;
	protected final float maxDist;
	protected final String tableName;

	protected AbstractFeatureModule(String tableName, float maxDist){
		this.tableName = tableName;
		this.maxDist = maxDist;
	}
	
	@Override
	public void init(PersistencyWriter<?> phandler) {
		this.phandler = phandler;
		this.phandler.open(this.tableName);
	}
	
	@Override
	public void init(DBSelector selector) {
		this.selector = selector;
	}

	private float[] arrayCache = null; //avoiding the creation of new arrays on every call
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void persist(String shotId, ReadableFloatVector fv) {
		PersistentTuple tuple = this.phandler.generateTuple(shotId, arrayCache = fv.toArray(arrayCache));
		this.phandler.persist(tuple);
	}

	@Override
	public List<StringDoublePair> getSimilar(String shotId, QueryConfig qc) {
		List<Map<String, String>> list = this.selector.getFeatureVectors("id", shotId);
		if(list.isEmpty()){
			return new ArrayList<>(1);
		}
		if(list.size() == 1){
			String featureString = list.get(0).get("feature");
			if(featureString == null){
				return new ArrayList<>(1);
			}
			return getSimilar(parseFeatureVectorString(featureString), qc);
		}
		
		TObjectDoubleMap<String> maxPool = new TObjectDoubleHashMap<>();
		for(Map<String, String> map : list){
			if(map == null){
				continue;
			}
			String featureString = map.get("feature");
			if(featureString == null){
				continue;
			}
			
			List<StringDoublePair> similar = getSimilar(parseFeatureVectorString(featureString), qc);
			
			for(StringDoublePair sdp : similar){
				if(maxPool.containsKey(sdp.key)){
					if(maxPool.get(sdp.key) < sdp.value){
						maxPool.put(sdp.key, sdp.value);
					}
				}else{
					maxPool.put(sdp.key, sdp.value);
				}
			}
			
		}
		
		ArrayList<StringDoublePair> _return = new ArrayList<>(maxPool.isEmpty() ? 1 : maxPool.size());
		for(String id : maxPool.keySet()){
			_return.add(new StringDoublePair(id, maxPool.get(id)));
		}
		
		return _return;
	}

	//this will become obsolete with future API change
	private float[] parseFeatureVectorString(String featureString){
		String[] stingVector = featureString.split(",");
		float[] featureVector = new float[stingVector.length];
		for(int i = 0; i < featureVector.length; ++i){
			try{
				featureVector[i] = Float.parseFloat(stingVector[i]);
			}catch(NumberFormatException e){
				//ignore
			}
		}
		return featureVector;
	}
	
	/**
	 * helper function to retrieve elements close to a vector which has to be generated by the feature module
	 */
	protected List<StringDoublePair> getSimilar(float[] vector, QueryConfig qc) {
		List<StringDoublePair> distances = this.selector.getNearestNeighbours(Config.getRetrieverConfig().getMaxResultsPerModule(), vector, "feature", qc);
		for(StringDoublePair sdp : distances){
			double dist = sdp.value;
			sdp.value = MathHelper.getScore(dist, maxDist);
		}
		return distances;
	}
	
	

	@Override
	public void finish() {
		if(this.phandler != null){
			this.phandler.close();
			this.phandler = null;
		}
		
		if(this.selector != null){
			this.selector.close();
			this.selector = null;
		}
	}

}

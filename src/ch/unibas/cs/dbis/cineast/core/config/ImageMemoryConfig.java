package ch.unibas.cs.dbis.cineast.core.config;

import java.io.File;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.eclipsesource.json.JsonObject;


public final class ImageMemoryConfig {

	private static final Logger LOGGER = LogManager.getLogger();

	private static final Policy DEFAULT_POLICY = Policy.AUTOMATIC;
	private static final int DEFAULT_SOFT_LIMIT = 3096;
	private static final int DEFAULT_HARD_LIMIT = 2048;
	private static final File DEFAULT_CACHE_LOCATION = new File(".");
	
	public static enum Policy{
		FORCE_DISK_CACHE, //cache to disk even if newInMemoryMultiImage is requested
		DISK_CACHE, //cache to disk unless newInMemoryMultiImage is requested
		AUTOMATIC, //keep in memory as long as threshold is not exceeded, makes exceptions for images not generated by the video decoder
		AVOID_CACHE //avoids cache until hard limit is reached
	}
	
	private final Policy cachingPolicy;
	private final long softMinMemory;
	private final long hardMinMemory;
	private final File cacheLocation;
	
	/**
	 * 
	 * @param softMemoryLimit Soft memory limit for in-memory frame cache in MB
	 * @param hardMemoryLimit Hard memory limit for in-memory frame cache in MB
	 * @param cachePolicy Caching Policy
	 * @param cacheLocation the file system location of the disk cache
	 * @throws IllegalArgumentException in case any of the memory limits is negative
	 * @throws NullPointerException in case the cachePolicy or cacheLocation is null
	 * @throws SecurityException in case access to cacheLocation is not permitted
	 */
	public ImageMemoryConfig(int softMemoryLimit, int hardMemoryLimit, Policy cachePolicy, File cacheLocation){
		if(softMemoryLimit < 0){
			throw new IllegalArgumentException("Memorylimit must me positive");
		}
		if(hardMemoryLimit < 0){
			throw new IllegalArgumentException("Memorylimit must me positive");
		}
		if(cachePolicy == null){
			throw new NullPointerException("CachePolicy cannot be null");
		}
		if(cacheLocation == null){
			throw new NullPointerException("CacheLocation cannot be null");
		}
		if(!(cacheLocation.exists() && cacheLocation.isDirectory()) || cacheLocation.mkdirs()){
			this.cacheLocation = new File(".");
			LOGGER.warn("Specified cache location ({}) is invalid, using default location: {}", cacheLocation.getAbsolutePath(), this.cacheLocation.getAbsolutePath());
		}else{
			this.cacheLocation = cacheLocation;
		}
		this.softMinMemory = 1024L * 1024L * softMemoryLimit;
		this.hardMinMemory = 1024L * 1024L * hardMemoryLimit;
		this.cachingPolicy = cachePolicy;
	}
	
	/**
	 * Creates an ImageMemoryConfig object with the default configuration. This is equivalent to ImageMemoryConfig(3096, 2048, Policy.AUTOMATIC);
	 */
	public ImageMemoryConfig(){
		this(DEFAULT_SOFT_LIMIT, DEFAULT_HARD_LIMIT, DEFAULT_POLICY, DEFAULT_CACHE_LOCATION);
	}
	
	/**
	 * @return the soft memory limit in bytes
	 */
	public final long getSoftMinMemory(){
		return this.softMinMemory;
	}
	
	/**
	 * @return the hard memory limit in bytes
	 */
	public final long getHardMinMemory(){
		return this.hardMinMemory;
	}
	
	/**
	 * @return the caching policy
	 */
	public final Policy getCachingPolicy(){
		return this.cachingPolicy;
	}
	
	/**
	 * @return the file system location of the cache
	 */
	public final File getCacheLocation(){
		return this.cacheLocation;
	}
	
	/**
	 * {
	 * 	"cachePolicy" : "AUTOMATIC",
	 * 	"softMemoryLimit" : 3096,
	 * 	"hardMemoryLimit" : 2048,
	 * 	"cacheLocation" : "."
	 * }
	 * @param config
	 * @return
	 */
	public static final ImageMemoryConfig parseJson(JsonObject config){		
		if(config == null){
			LOGGER.warn("JsonObject was null in ImageMemoryConfig.parseJson, using default settings");
			return new ImageMemoryConfig();
		}
		
		int softMemoryLimit = DEFAULT_SOFT_LIMIT, hardMemoryLimit = DEFAULT_HARD_LIMIT;
		Policy cachePolicy = DEFAULT_POLICY;
		File cacheLocation = DEFAULT_CACHE_LOCATION;
		
		if(config.get("cachePolicy") != null){
			String policy = "";
			try{
				policy = config.get("cachePolicy").asString();
				cachePolicy = Policy.valueOf(policy);
			}catch(UnsupportedOperationException notAString){
				LOGGER.error("could not parse cache.cachePolicy, entry is not a string");
			}catch(IllegalArgumentException notAPolicy){
				LOGGER.error("could not parse cache.cachePolicy, {} is not a valid policy", policy);
			}
		}
		
		if(config.get("softMemoryLimit") != null){
			try{
				int limit = config.get("softMemoryLimit").asInt();
				if(limit < 0){
					LOGGER.error("could not parse 'cache.softMemoryLimit', entry cannot be negaitve");
				}else{
					softMemoryLimit = limit;
				}
			}catch(UnsupportedOperationException notANumber){
				LOGGER.error("could not parse 'cache.softMemoryLimit', entry is not a number");
			}
		}
		
		if(config.get("hardMemoryLimit") != null){
			try{
				int limit = config.get("hardMemoryLimit").asInt();
				if(limit < 0){
					LOGGER.error("could not parse 'cache.hardMemoryLimit', entry cannot be negaitve");
				}else{
					hardMemoryLimit = limit;
				}
			}catch(UnsupportedOperationException notANumber){
				LOGGER.error("could not parse 'cache.hardMemoryLimit', entry is not a number");
			}
		}
		
		if(config.get("cacheLocation") != null){
			String location = "";
			try{
				location = config.get("cacheLocation").asString();
				File folder = new File(location);
				if(!folder.exists()){
					LOGGER.warn("Error while parsing 'cache.cacheLocation': folder {} does not exist, ignoring 'cacheLocation'", folder.getAbsolutePath());
				}else if(!folder.isDirectory()){
					LOGGER.warn("Error while parsing 'cache.cacheLocation': {} is not a directory, ignoring 'cacheLocation'", folder.getAbsolutePath());
				}else if(!folder.canRead()){
					LOGGER.warn("Error while parsing 'cache.cacheLocation': {} is not readable, ignoring 'cacheLocation'", folder.getAbsolutePath());
				}else{
					cacheLocation = folder;
				}
			}catch(UnsupportedOperationException nameNotAString){
				LOGGER.warn("Could not parse job config entry 'cache.cacheLocation': entry is not a valid string, ignoring 'cacheLocation'");
			}catch(SecurityException canNotRead){
				LOGGER.warn("Error while parsing 'cache.cacheLocation': security settings do not permitt access, ignoring 'cacheLocation'");
			}
			
		}
		
		return new ImageMemoryConfig(softMemoryLimit, hardMemoryLimit, cachePolicy, cacheLocation);
	}
	
	@Override
	public String toString(){
		StringBuilder builder = new StringBuilder();
		builder.append("\"cache\" : { \"cachePolicy\" : \"");
		builder.append(this.cachingPolicy.toString());
		builder.append("\", \"softMemoryLimit\" : ");
		builder.append(this.softMinMemory / 1024L / 1024L);
		builder.append("\", \"hardMemoryLimit\" : ");
		builder.append(this.hardMinMemory / 1024L / 1024L);
		builder.append(", \"cacheLocation\" : \"");
		builder.append(this.cacheLocation.getAbsolutePath());
		builder.append("\" }");
		return builder.toString();
	}
	
}
